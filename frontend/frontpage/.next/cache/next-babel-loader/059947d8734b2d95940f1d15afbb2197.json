{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\nfunction getRouteRegex(normalizedRoute) {\n  // Escape all characters that could be considered RegEx\n  const escapedRoute = escapeRegex(normalizedRoute.replace(/\\/$/, '') || '/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = escapedRoute.replace(/\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g, (_, $1) => {\n    const isOptional = /^\\\\\\[.*\\\\\\]$/.test($1);\n    if (isOptional) {\n      $1 = $1.slice(2, -2);\n    }\n    const isCatchAll = /^(\\\\\\.){3}/.test($1);\n    if (isCatchAll) {\n      $1 = $1.slice(6);\n    }\n    groups[$1 // Un-escape key\n    .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1') // eslint-disable-next-line no-sequences\n    ] = {\n      pos: groupIndex++,\n      repeat: isCatchAll\n    };\n    return isCatchAll ? isOptional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n  });\n  let namedParameterizedRoute; // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (true) {\n    namedParameterizedRoute = escapedRoute.replace(/\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g, (_, $1) => {\n      const isCatchAll = /^(\\\\\\.){3}/.test($1);\n      const key = $1 // Un-escape key\n      .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1').replace(/^\\.{3}/, '');\n      return isCatchAll ? `/(?<${escapeRegex(key)}>.+?)` : `/(?<${escapeRegex(key)}>[^/]+?)`;\n    });\n  }\n  return {\n    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),\n    groups,\n    namedRegex: namedParameterizedRoute ? `^${namedParameterizedRoute}(?:/)?$` : undefined\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["escapeRegex","str","replace","getRouteRegex","normalizedRoute","escapedRoute","groups","groupIndex","parameterizedRoute","_","$1","isOptional","test","slice","isCatchAll","pos","repeat","namedParameterizedRoute","key","re","RegExp","namedRegex","undefined"],"mappings":";;;sCAAA;AACA;AACA,SAASA,WAAT,CAAqBC,GAArB,EAAkC;EAChC,OAAOA,GAAG,CAACC,OAAJD,CAAY,sBAAZA,EAAoC,MAApCA,CAAP;AACD;AAEM,SAASE,aAAT,CACLC,eADK,EAML;EACA;EACA,MAAMC,YAAY,GAAGL,WAAW,CAACI,eAAe,CAACF,OAAhBE,CAAwB,KAAxBA,EAA+B,EAA/BA,CAAAA,IAAsC,GAAvC,CAAhC;EAEA,MAAME,MAAiE,GAAG,CAAA,CAA1E;EACA,IAAIC,UAAU,GAAG,CAAjB;EAEA,MAAMC,kBAAkB,GAAG,YAAY,CAACN,OAAb,CACzB,6BADyB,EAEzB,CAACO,CAAD,EAAIC,EAAJ,KAAW;IACT,MAAMC,UAAU,GAAG,cAAA,CAAeC,IAAf,CAAoBF,EAApB,CAAnB;IACA,IAAIC,UAAJ,EAAgB;MACdD,EAAE,GAAGA,EAAE,CAACG,KAAHH,CAAS,CAATA,EAAY,CAAC,CAAbA,CAALA;IACD;IACD,MAAMI,UAAU,GAAG,YAAA,CAAaF,IAAb,CAAkBF,EAAlB,CAAnB;IACA,IAAII,UAAJ,EAAgB;MACdJ,EAAE,GAAGA,EAAE,CAACG,KAAHH,CAAS,CAATA,CAALA;IACD;IACD,MAAM,CACJ,EACE;IAAA,CACCR,OAFH,CAEW,0BAFX,EAEuC,IAFvC,CAGA;IAAA,CAJF,GAKI;MAAEa,GAAG,EAAER,UAAU,EAAjB;MAAqBS,MAAM,EAAEF;IAA7B,CALJ;IAMA,OAAOA,UAAU,GAAIH,UAAU,GAAG,aAAH,GAAmB,QAAjC,GAA6C,WAA9D;EACD,CAlBwB,CAA3B;EAqBA,IAAIM,uBAAJ,CAEA;EACA;EACA,UAAmC;IACjCA,uBAAuB,GAAGZ,YAAY,CAACH,OAAbG,CACxB,6BADwBA,EAExB,CAACI,CAAD,EAAIC,EAAJ,KAAW;MACT,MAAMI,UAAU,GAAG,YAAA,CAAaF,IAAb,CAAkBF,EAAlB,CAAnB;MACA,MAAMQ,GAAG,GAAG,EACV;MAAA,CACChB,OAFS,CAED,0BAFC,EAE2B,IAF3B,CAAA,CAGTA,OAHS,CAGD,QAHC,EAGS,EAHT,CAAZ;MAKA,OAAOY,UAAU,GACZ,OAAMd,WAAW,CAACkB,GAAD,CAAM,OADX,GAEZ,OAAMlB,WAAW,CAACkB,GAAD,CAAM,UAF5B;IAGD,CAZuBb,CAA1BY;EAcD;EAED,OAAO;IACLE,EAAE,EAAE,IAAIC,MAAJ,CAAW,GAAA,GAAMZ,kBAAN,GAA2B,SAAtC,EAAiD,GAAjD,CADC;IAELF,MAFK;IAGLe,UAAU,EAAEJ,uBAAuB,GAC9B,IAAGA,uBAAwB,SADG,GAE/BK;EALC,CAAP;AAOD","sourcesContent":["// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  groups: { [groupName: string]: { pos: number; repeat: boolean } }\n} {\n  // Escape all characters that could be considered RegEx\n  const escapedRoute = escapeRegex(normalizedRoute.replace(/\\/$/, '') || '/')\n\n  const groups: { [groupName: string]: { pos: number; repeat: boolean } } = {}\n  let groupIndex = 1\n\n  const parameterizedRoute = escapedRoute.replace(\n    /\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,\n    (_, $1) => {\n      const isOptional = /^\\\\\\[.*\\\\\\]$/.test($1)\n      if (isOptional) {\n        $1 = $1.slice(2, -2)\n      }\n      const isCatchAll = /^(\\\\\\.){3}/.test($1)\n      if (isCatchAll) {\n        $1 = $1.slice(6)\n      }\n      groups[\n        $1\n          // Un-escape key\n          .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1')\n        // eslint-disable-next-line no-sequences\n      ] = { pos: groupIndex++, repeat: isCatchAll }\n      return isCatchAll ? (isOptional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n    }\n  )\n\n  let namedParameterizedRoute: string | undefined\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    namedParameterizedRoute = escapedRoute.replace(\n      /\\/\\\\\\[([^/]+?)\\\\\\](?=\\/|$)/g,\n      (_, $1) => {\n        const isCatchAll = /^(\\\\\\.){3}/.test($1)\n        const key = $1\n          // Un-escape key\n          .replace(/\\\\([|\\\\{}()[\\]^$+*?.-])/g, '$1')\n          .replace(/^\\.{3}/, '')\n\n        return isCatchAll\n          ? `/(?<${escapeRegex(key)}>.+?)`\n          : `/(?<${escapeRegex(key)}>[^/]+?)`\n      }\n    )\n  }\n\n  return {\n    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),\n    groups,\n    namedRegex: namedParameterizedRoute\n      ? `^${namedParameterizedRoute}(?:/)?$`\n      : undefined,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}